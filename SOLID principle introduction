SOLID Introduction 
SOLID principles are the design principles that enable us manage most of the software design problems
The term SOLID is an acronym for five design principles intended to make software designs more understandable, flexible and maintainable
The principles are a subset of many principles promoted by Robert C. Martin
The SOLID acronym was first introduced by Michael Feathers

 

SOLID Acronym 
S : Single Responsibility Principle (SRP) 
O : Open closed Principle (OSP) 
L :  Liskov substitution Principle (LSP) 
I  :  Interface Segregation Principle (ISP) 
D : Dependency Inversion Principle (DIP)


Single Responsibility Principle 
Robert C. Martin expresses the principle as, "A class should have only one reason to change”
Every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class
Liskov Substitution Principle 
Introduced by Barbara Liskov state that “objects in a program should be replaceable with instances of their sub-types without altering the correctness of that program”
If a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module
We can also state that Derived types must be substitutable for their base types
Open/Closed Principle 
“Software entities should be open for extension, but closed for modification”
The design and writing of the code should be done in a way that new functionality should be added with minimum changes in the existing code 
The design should be done in a way to allow the adding of new functionality as new classes, keeping as much as possible existing code unchanged
Interface Segregation Principle 
“Many client-specific interfaces are better than one general-purpose interface”
We should not enforce clients to implement interfaces that they don't use. Instead of creating one big interface we can break down it to smaller interfaces
Dependency Inversion Principle 
One should “depend upon abstractions, [not] concretions"
Abstractions should not depend on the details whereas the details should depend on abstractions
High-level modules should not depend on low level modules 
If we don’t follow SOLID Principles we  
End up with tight or strong coupling of the code with many other modules/applications
Tight coupling causes time to implement any new requirement, features or any bug fixes and some times it creates unknown issues
End up with a code which is not testable
End up with duplication of code
End up creating new bugs by fixing another bug
End up with many unknown issues in the application development cycle
Following SOLID Principles helps us to  
Achieve reduction in complexity of code
Increase readability, extensibility and maintenance
Reduce error and implement Reusability
Achieve Better testability
Reduce tight coupling
Solution to develop a successful application depends on  
Architecture : choosing an architecture is the first step in designing application based on the requirements. Example : MVC, WEBAPI, MVVM..etc
Design Principles : Application development process need to follow the design principles
Design Patterns : We need to choose correct design patterns to build the software
If you are confused on how we can apply these design principles in the application development? Don’t worry as we are going to take a look at them in greater details in the upcoming videos.
